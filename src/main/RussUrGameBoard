//2019-25-11 We want to use the Model View Controller pattern.
//Russ completely updated and renamed the old Board class to RussUrGameBoard.java to better collaborate with the recently added
// RussTile, RussNormalTile, RussRosetteTile, RussPlayer, RussHuman, RussToken classes.  
// Not certain at this point what, if any, impact there will be with using Graphics2D in the GUI View class.
//
// Also, there may be some overlay of this UrGameBoard (Model) class, and the Game (Controller) class.  We will reconcile this
// during further development of the design. 



import java.util.*;

/**
 * ---------------------------------------------------------------------------
 * File name: RussGameBoard.java
 * Project name: GameOfUr
 * ---------------------------------------------------------------------------
 * Creator's name and email: Russ Stipelcovich, stipelcovich@etsu.edu
 * Course:  CSCI 1260
 * Creation Date: Nov 23, 2019
 * ---------------------------------------------------------------------------
 */

/**
 * The UrBoardGame class will be the Model part of the MVC pattern.
 *
 * <hr>
 * Date created: Nov 23, 2019
 * <hr>
 * @author Russ Stipelcovich
 */
public class RussGameBoard implements Runnable  //Not sure that this class will include Run() method; it may be in the Game class.

{
    //RussUrGameBoard
    /** This is the game board. it manages all tiles
     * @see Tile */
    
    private Tile[] board;

    //players
    /** Array that contains all(2) players*/
    
    private Player player[];
    
    /** Array of lists that contain each players finished tokens*/
    
    private ArrayList<Token> finishedTokens[];
    
    /** ID of player whose turn it currently is*/
    
    private int activePlayer;

    //Output device
    /** This is the device that manages the output. It can be on the console (see ConsoleOutput), graphical (to-do) or non at all (see Output)
     * @see Output
     * @see ConsoleOutput
     */
    
    private Output output;  This is the interface point to the GUI interface.

   

    /**The constructor of UrGameBoard manages the game setup. It initializes the game board, the token lists, etc...)
     * @param player1 First player (Human player1)
     * @param player2 Second player (Human player2)
     * @param output Manages output (e.g. to console or a GUI or not at all)
     * 
     *
     * @see Player
     * @see Output
     * @see ConsoleOutput - Note Output TBD
     */
    public UrGameBoard(Human(Player) player1, Human(Player) player2, Output output) // We may type cast to Player object
    
    {
        this.output = output;  //The GUI implementaton "plugs" in here.
        
        //Setup Game Board
        //create board tiles
        
        board = new Tile[14];
        
        for(int i = 0; i<board.length; i++)
        
        {
            //tiles 0-4 and 12-13 are private; tiles 3, 7 and 13 are double roll tiles
            
            board[i] = new Tile(/*ID:*/i,/*isPrivate:*/(i<=3||i>=12), /*rollAgain:*/((i==3)||(i==7)||(i==13)) );
        }

        //Setup Players
        
        player = new Player[2]; //This is an array of two Player objects
        player[0] = player1;
        player[1] = player2;
        activePlayer = (int)(Math.random()*2);

        finishedTokens = new ArrayList[2];  //Looks like and array [int] of ArrayLists
        finishedTokens[0] = new ArrayList<Token>();
        finishedTokens[1] = new ArrayList<Token>();

        //print board
        
        output.printBoard(board,player); //this is interface to GUI

        //Start loop
        
        run();  //new Thread(this).start() Need to review the correct implementation of the Thread object; May be part of Game class.
    }

  
  // Note that the methods below may be considered part of the Game class (Controller).  If so, it will be removed from this class.   
	// There may be some overlay with other classes as well.

	/**This method takes care of the gameloop. It runs in an infinite while loop until the game is won. It calls turn() for the currently active player.*/
    
    public void run()
    
    {
        gameloop:  /not sure of this syntax.
        
        while(true)
        
        {
            //Player turns
            //also: test if player has already won
            
            if(turn(player[activePlayer]))
            
            {
                 break gameloop;
            }

            //Output current state of the game
            
            output.printBoard(board, player);

         }
    }

    /** This method takes care of one players turn.
     * It first changes the active player for the next turn,
     * then rolls a dice, then ask what the player wants do do, if there is a possible move
     * and finally makes that move, if possible
     *
     * @param player player whos turn it is;
     * @return true if player has won, false otherwise*/
    
    private boolean turn(Player player)
    
    {
    
        //count turns
        
        turnCounter++;
        
        //change active player (changend back in move() if you land on a double roll)
        
        activePlayer = (activePlayer+1)this.player.length;

        //roll Dice
        
        int dice = rollDice();
        
        output.print("Dice: "+dice+"\n");

        // move token if valid move exists
        
        if(!doValidMovesExsist(board,player,dice))
        
        {
            return false;
        }

        //move otherwise. throw error if move is not possible
        
        move(player, player.turn(board, this.player[activePlayer].getTokens(), dice), dice);
            
            //throw new Error("Illegal Move ("+player.getID());

        //check if player has won
        
        if(finishedTokens[player.getID()].size()==7)
        
        {
            output.print(player.getName() + " won!\n");

            return true;
        }

        return false;
    }


    /** This method moves token a token if possible
     * @param player Player whose turn it is
     * @param token Token that should be moved
     * @param dice Number of fields to move
     * @return true if move is successful, false otherwise
     */
    private boolean move(Player player, Token token, int dice)
    
    {
        //Don't move if dice is zero
    
        if(dice == 0)
        
        {
            return true;
        }

        //Don't move if there are no vaild moves
        
        if(!doValidMovesExsist(board,player,dice))
        
        {
            return true;
        }

        
        if(player.getID() != token.getPlayer())
        
            return false;

        //check if move is valid
        
        if(!isValidMove(board,token,dice))
        
        {
            return false;
        }

        //test if tile reached the end
        
        if(token.getTile()!=null && token.getTile().getID()+dice==14)
        
        {
            token.getTile().removeToken(token);
         
            finishedTokens[player.getID()].add(token);
            
            player.removeToken(token);
             
            return true;
        }

        //calculate new tile ID
        
        Tile newTile;
        
        if(token.getTile()==null)
        
        {
            //If token is not on board yet
            newTile = board[dice-1];
        }
        
        else
        
        {
              //If token is already on board
              newTile = board[token.getTile().getID() + dice];
        }

        //Change active player back if you land on a double roll
        
        if(newTile.isRollAgain())
        
        {
            activePlayer = player.getID();
        }

        //actually move token
        
        if(token.getTile()!=null)
        
        {
            token.getTile().removeToken(token);
        }
        
        newTile.addToken(token);

        return true;
    }

    /** This method test if a move is valid
     * @param board game board
     * @param token token that should be moved
     * @param dice number of tiles to move
     * @return false if move is invalid
     *          true otherwise
     * */
    public static boolean isValidMove(Tile[] board, Token token, int dice){
        //move is always valid if dice is zero*/
        if(dice == 0){ return true; }

        //calculate new tile ID
        int newTileID;
        //test if token is not on board yet
        if(token.getTile()==null){
            newTileID = dice-1;
        }else {
            newTileID = token.getTile().getID() + dice;
        }

        //test if player reached the goal
        if(newTileID == board.length) { return true; }

        //test if player moved out of board area
        else if(newTileID>board.length){ return false; }

        //find new Tile
        Tile newTile = board[newTileID];

        //test if tile is blocked by own token
        if(newTile.isOccupiedByOwn(token.getPlayer())){ return false; }

        //test if other player is on safespot
        if(!newTile.isPrivate() && newTile.isRollAgain() && newTile.isOccupiedByOpponent(token.getPlayer())){ return false; }

        // return true otherwise*/
        return true;
    }

    /** This method tests if there are valid moves left for a player and a dice result
     * @param board Game board
     * @param player Player whose turn it is
     * @param dice dice result
     * @return true if vaild turns exist, false otherwise
     */
     
     public static boolean doValidMovesExsist(Tile[] board, Player player, int dice)
     
     {
         for(Token token:player.tokens)
         
         {
             if(isValidMove(board,token,dice))
             
             return true;
         }

         return false;
     }

    /** This method rolls 4 binary dice and returns the sum of the values 
     * @return: 0 with probability 1/16
     *          1 with probability 4/16
     *          2 with probability 6/16
     *          3 with probability 4/16
     *          4 with probability 1/16
     */
    
    private static int rollDice()
    
    {
        return ((Math.random()<0.5)?1:0)+((Math.random()<0.5)?1:0)+((Math.random()<0.5)?1:0)+((Math.random()<0.5)?1:0);
    }

    

}
